mips_architecture:
  r_type_instructions:
    description: "Opcode is 000000 (0x00) for all standard R-Types. Operation is determined by the 'funct' code (bits [5:0])."
    format: "opcode | rs | rt | rd | shamt | funct"
    opcode_binary: "000000"
    instructions:
      - name: "ADD"
        funct_binary: "100000"
        funct_hex: "0x20"
        alu_control: "0000"
        operation: "rd = rs + rt"
      - name: "SUB"
        funct_binary: "100010"
        funct_hex: "0x22"
        alu_control: "0001"
        operation: "rd = rs - rt"
      - name: "AND"
        funct_binary: "100100"
        funct_hex: "0x24"
        alu_control: "0010"
        operation: "rd = rs & rt"
      - name: "OR"
        funct_binary: "100101"
        funct_hex: "0x25"
        alu_control: "0011"
        operation: "rd = rs | rt"
      - name: "SLT"
        funct_binary: "101010"
        funct_hex: "0x2A"
        alu_control: "1000"
        operation: "rd = (rs < rt) ? 1 : 0"
      - name: "SLL"
        funct_binary: "000000"
        funct_hex: "0x00"
        alu_control: "0101"
        operation: "rd = rt << shamt"
      - name: "SRL"
        funct_binary: "000010"
        funct_hex: "0x02"
        alu_control: "0110"
        operation: "rd = rt >> shamt"
      - name: "SLLV"
        funct_binary: "000100"
        funct_hex: "0x04"
        alu_control: "0101"
        operation: "rd = rt << rs (Shift mux enabled)"
      - name: "SRLV"
        funct_binary: "000110"
        funct_hex: "0x06"
        alu_control: "0110"
        operation: "rd = rt >> rs (Shift mux enabled)"

  i_type_instructions:
    description: "Operation is determined by the 'opcode' (bits [31:26])."
    format: "opcode | rs | rt | immediate"
    instructions:
      - name: "BEQ"
        opcode_binary: "000100"
        opcode_hex: "0x04"
        alu_control: "0001 (SUB)"
        operation: "if (rs==rt) branch"
      - name: "ADDI"
        opcode_binary: "001000"
        opcode_hex: "0x08"
        alu_control: "0000 (ADD)"
        operation: "rt = rs + imm (Sign Ext)"
      - name: "ANDI"
        opcode_binary: "001100"
        opcode_hex: "0x0C"
        alu_control: "0010 (AND)"
        operation: "rt = rs & imm (Zero Ext)"
      - name: "ORI"
        opcode_binary: "001101"
        opcode_hex: "0x0D"
        alu_control: "0011 (OR)"
        operation: "rt = rs | imm (Zero Ext)"
      - name: "XORI"
        opcode_binary: "001110"
        opcode_hex: "0x0E"
        alu_control: "0100 (XOR)"
        operation: "rt = rs ^ imm (Zero Ext)"
      - name: "LW"
        opcode_binary: "100011"
        opcode_hex: "0x23"
        alu_control: "0000 (ADD)"
        operation: "rt = mem[rs + imm]"
      - name: "SW"
        opcode_binary: "101011"
        opcode_hex: "0x2B"
        alu_control: "0000 (ADD)"
        operation: "mem[rs + imm] = rt"

  j_type_instructions:
    description: "Operation determined by opcode."
    format: "opcode | address"
    instructions:
      - name: "J"
        opcode_binary: "000010"
        opcode_hex: "0x02"
        operation: "pc = jump_address"

  control_signals_summary:
    description: "Signals generated by Smart Select logic based on opcodes."
    signals:
      - name: "i_pc_br_sel"
        condition: "(Opcode == BEQ) AND (Zero_Flag == 1)"
      - name: "i_pc_jmp_sel"
        condition: "(Opcode == J)"
      - name: "i_dest_sel"
        condition: "(Opcode == R-Type 0x00) -> Selects RD. Else selects RT."
      - name: "i_alu_src"
        condition: "(Opcode != R-Type) AND (Opcode != BEQ) -> Selects Imm."
      - name: "mem_write"
        condition: "(Opcode == SW)"
      - name: "mem_to_reg"
        condition: "(Opcode == LW)"
      - name: "o_sel_shift"
        condition: "(Funct == SLLV) OR (Funct == SRLV)"